var N = null;var searchIndex = {};
searchIndex["bitflags"]={"doc":"A typesafe bitmask flag generator useful for sets of C-style bitmask flags. It can be used for creating typesafe wrappers around C APIs.","items":[[14,"bitflags","bitflags","The macro used to generate the flag structure.",N,N]],"paths":[]};
searchIndex["bitflags_serde_shim"]={"doc":"`bitflags` crate Serde shims","items":[[14,"impl_serde_for_bitflags","bitflags_serde_shim","Implements `Serialize` and `Deserialize` for a `bitflags!` generated structure.",N,N]],"paths":[]};
searchIndex["enum_primitive"]={"doc":"This crate exports a macro `enum_from_primitive!` that wraps an `enum` declaration and automatically adds an implementation of `num::FromPrimitive` (reexported here), to allow conversion from primitive integers to the enum.  It therefore provides an alternative to the built-in `#[derive(FromPrimitive)]`, which requires the unstable `std::num::FromPrimitive` and is disabled in Rust 1.0.","items":[[4,"Option","enum_primitive","The `Option` type. See the module level documentation for more.",N,N],[13,"None","","No value",0,N],[13,"Some","","Some value `T`",0,N],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",1,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",1,[[["f64"]],["option"]]],[14,"enum_from_primitive_impl_ty","","Helper macro for internal use by `enum_from_primitive!`.",N,N],[14,"enum_from_primitive_impl","","Helper macro for internal use by `enum_from_primitive!`.",N,N],[14,"enum_from_primitive","","Wrap this macro around an `enum` declaration to get an automatically generated implementation of `num::FromPrimitive`.",N,N],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into_iter","","",0,[[["self"]],["i"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["option"]]],[11,"from","","",0,[[["option"]],["option"]]],[11,"from","","",0,[[["option"]],["option"]]],[11,"from_iter","","Takes each element in the [`Iterator`]: if it is [`None`][Option::None], no further elements are taken, and the [`None`][Option::None] is returned. Should no [`None`][Option::None] occur, a container with the values of each [`Option`] is returned.",0,[[["i"]],["option"]]],[11,"into_result","","",0,[[["self"]],["result",["noneerror"]]]],[11,"from_ok","","",0,[[["t"]],["option"]]],[11,"from_error","","",0,[[["noneerror"]],["option"]]],[11,"default","","Returns [`None`][Option::None].",0,[[],["option"]]],[11,"hash","","",0,N],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",0,[[["self"]],["intoiter"]]],[11,"clone","","",0,[[["self"]],["option"]]],[11,"partial_cmp","","",0,[[["self"],["option"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["option"]],["bool"]]],[11,"le","","",0,[[["self"],["option"]],["bool"]]],[11,"gt","","",0,[[["self"],["option"]],["bool"]]],[11,"ge","","",0,[[["self"],["option"]],["bool"]]],[11,"cmp","","",0,[[["self"],["option"]],["ordering"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",0,[[["self"],["option"]],["bool"]]],[11,"ne","","",0,[[["self"],["option"]],["bool"]]],[11,"is_some","","Returns `true` if the option is a [`Some`] value.",0,[[["self"]],["bool"]]],[11,"is_none","","Returns `true` if the option is a [`None`] value.",0,[[["self"]],["bool"]]],[11,"as_ref","","Converts from `Option<T>` to `Option<&T>`.",0,[[["self"]],["option"]]],[11,"as_mut","","Converts from `Option<T>` to `Option<&mut T>`.",0,[[["self"]],["option"]]],[11,"as_pin_ref","","Converts from `Pin<&Option<T>>` to `Option<Pin<&T>>`",0,[[["pin",["option"]]],["option",["pin"]]]],[11,"as_pin_mut","","Converts from `Pin<&mut Option<T>>` to `Option<Pin<&mut T>>`",0,[[["pin",["option"]]],["option",["pin"]]]],[11,"expect","","Unwraps an option, yielding the content of a [`Some`].",0,[[["self"],["str"]],["t"]]],[11,"unwrap","","Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].",0,[[["self"]],["t"]]],[11,"unwrap_or","","Returns the contained value or a default.",0,[[["self"],["t"]],["t"]]],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",0,[[["self"],["f"]],["t"]]],[11,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.",0,[[["self"],["f"]],["option"]]],[11,"map_or","","Applies a function to the contained value (if any), or returns the provided default (if not).",0,[[["self"],["u"],["f"]],["u"]]],[11,"map_or_else","","Applies a function to the contained value (if any), or computes a default (if not).",0,[[["self"],["d"],["f"]],["u"]]],[11,"ok_or","","Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err)`].",0,[[["self"],["e"]],["result"]]],[11,"ok_or_else","","Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err())`].",0,[[["self"],["f"]],["result"]]],[11,"iter","","Returns an iterator over the possibly contained value.",0,[[["self"]],["iter"]]],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",0,[[["self"]],["itermut"]]],[11,"and","","Returns [`None`] if the option is [`None`], otherwise returns `optb`.",0,[[["self"],["option"]],["option"]]],[11,"and_then","","Returns [`None`] if the option is [`None`], otherwise calls `f` with the wrapped value and returns the result.",0,[[["self"],["f"]],["option"]]],[11,"filter","","Returns `None` if the option is `None`, otherwise calls `predicate` with the wrapped value and returns:",0,[[["self"],["p"]],["option"]]],[11,"or","","Returns the option if it contains a value, otherwise returns `optb`.",0,[[["self"],["option"]],["option"]]],[11,"or_else","","Returns the option if it contains a value, otherwise calls `f` and returns the result.",0,[[["self"],["f"]],["option"]]],[11,"xor","","Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns `None`.",0,[[["self"],["option"]],["option"]]],[11,"get_or_insert","","Inserts `v` into the option if it is [`None`], then returns a mutable reference to the contained value.",0,[[["self"],["t"]],["t"]]],[11,"get_or_insert_with","","Inserts a value computed from `f` into the option if it is [`None`], then returns a mutable reference to the contained value.",0,[[["self"],["f"]],["t"]]],[11,"take","","Takes the value out of the option, leaving a [`None`] in its place.",0,[[["self"]],["option"]]],[11,"replace","","Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a [`Some`] in its place without deinitializing either one.",0,[[["self"],["t"]],["option"]]],[11,"cloned","","Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the option.",0,[[["self"]],["option"]]],[11,"cloned","","Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the option.",0,[[["self"]],["option"]]],[11,"unwrap_or_default","","Returns the contained value or a default",0,[[["self"]],["t"]]],[11,"deref","","Converts from `&Option<T>` to `Option<&T::Target>`.",0,[[["self"]],["option"]]],[11,"transpose","","Transposes an `Option` of a `Result` into a `Result` of an `Option`.",0,[[["self"]],["result",["option"]]]]],"paths":[[4,"Option"],[8,"FromPrimitive"]]};
searchIndex["enum_primitive_serde_shim"]={"doc":"`enum_primitive` crate Serde shims","items":[[14,"impl_serde_for_enum_primitive","enum_primitive_serde_shim","Implements `Serialize` and `Deserialize` for an `enum_from_primitive!` generated enum.",N,N]],"paths":[]};
searchIndex["mime"]={"doc":"Mime","items":[[3,"Mime","mime","A parsed mime or media type.",N,N],[3,"Name","","A section of a `Mime`.",N,N],[3,"FromStrError","","An error when parsing a `Mime` from a string.",N,N],[3,"Params","","An iterator over the parameters of a MIME.",N,N],[17,"STAR","","",N,N],[17,"TEXT","","text",N,N],[17,"IMAGE","","image",N,N],[17,"AUDIO","","audio",N,N],[17,"VIDEO","","video",N,N],[17,"APPLICATION","","application",N,N],[17,"MULTIPART","","multipart",N,N],[17,"MESSAGE","","message",N,N],[17,"MODEL","","model",N,N],[17,"FONT","","font",N,N],[17,"PLAIN","","plain",N,N],[17,"HTML","","html",N,N],[17,"XML","","xml",N,N],[17,"JAVASCRIPT","","javascript",N,N],[17,"CSS","","css",N,N],[17,"CSV","","csv",N,N],[17,"EVENT_STREAM","","event-stream",N,N],[17,"VCARD","","vcard",N,N],[17,"JSON","","json",N,N],[17,"WWW_FORM_URLENCODED","","x-www-form-urlencoded",N,N],[17,"MSGPACK","","msgpack",N,N],[17,"OCTET_STREAM","","octet-stream",N,N],[17,"PDF","","pdf",N,N],[17,"WOFF","","woff",N,N],[17,"WOFF2","","woff2",N,N],[17,"FORM_DATA","","form-data",N,N],[17,"BMP","","bmp",N,N],[17,"GIF","","gif",N,N],[17,"JPEG","","jpeg",N,N],[17,"PNG","","png",N,N],[17,"SVG","","svg",N,N],[17,"BASIC","","basic",N,N],[17,"MPEG","","mpeg",N,N],[17,"MP4","","mp4",N,N],[17,"OGG","","ogg",N,N],[17,"CHARSET","","charset",N,N],[17,"BOUNDARY","","boundary",N,N],[17,"UTF_8","","utf-8",N,N],[17,"STAR_STAR","","`*/*`",N,N],[17,"TEXT_STAR","","`text/*`",N,N],[17,"TEXT_PLAIN","","`text/plain`",N,N],[17,"TEXT_PLAIN_UTF_8","","`text/plain; charset=utf-8`",N,N],[17,"TEXT_HTML","","`text/html`",N,N],[17,"TEXT_HTML_UTF_8","","`text/html; charset=utf-8`",N,N],[17,"TEXT_CSS","","`text/css`",N,N],[17,"TEXT_CSS_UTF_8","","`text/css; charset=utf-8`",N,N],[17,"TEXT_JAVASCRIPT","","`text/javascript`",N,N],[17,"TEXT_XML","","`text/xml`",N,N],[17,"TEXT_EVENT_STREAM","","`text/event-stream`",N,N],[17,"TEXT_CSV","","`text/csv`",N,N],[17,"TEXT_CSV_UTF_8","","`text/csv; charset=utf-8`",N,N],[17,"TEXT_TAB_SEPARATED_VALUES","","`text/tab-separated-values`",N,N],[17,"TEXT_TAB_SEPARATED_VALUES_UTF_8","","`text/tab-separated-values; charset=utf-8`",N,N],[17,"TEXT_VCARD","","`text/vcard`",N,N],[17,"IMAGE_STAR","","`image/*`",N,N],[17,"IMAGE_JPEG","","`image/jpeg`",N,N],[17,"IMAGE_GIF","","`image/gif`",N,N],[17,"IMAGE_PNG","","`image/png`",N,N],[17,"IMAGE_BMP","","`image/bmp`",N,N],[17,"IMAGE_SVG","","`image/svg+xml`",N,N],[17,"FONT_WOFF","","`font/woff`",N,N],[17,"FONT_WOFF2","","`font/woff2`",N,N],[17,"APPLICATION_JSON","","`application/json`",N,N],[17,"APPLICATION_JAVASCRIPT","","`application/javascript`",N,N],[17,"APPLICATION_JAVASCRIPT_UTF_8","","`application/javascript; charset=utf-8`",N,N],[17,"APPLICATION_WWW_FORM_URLENCODED","","`application/x-www-form-urlencoded`",N,N],[17,"APPLICATION_OCTET_STREAM","","`application/octet-stream`",N,N],[17,"APPLICATION_MSGPACK","","`application/msgpack`",N,N],[17,"APPLICATION_PDF","","`application/pdf`",N,N],[17,"MULTIPART_FORM_DATA","","`multipart/form-data`",N,N],[11,"type_","","Get the top level media type for this `Mime`.",0,[[["self"]],["name"]]],[11,"subtype","","Get the subtype of this `Mime`.",0,[[["self"]],["name"]]],[11,"suffix","","Get an optional +suffix for this `Mime`.",0,[[["self"]],["option",["name"]]]],[11,"get_param","","Look up a parameter by name.",0,[[["self"],["n"]],["option",["name"]]]],[11,"params","","Returns an iterator over the parameters.",0,[[["self"]],["params"]]],[11,"as_str","","Get the value of this `Name` as a string.",1,[[["self"]],["str"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into_iter","","",3,[[["self"]],["i"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"next","","",3,[[["self"]],["option"]]],[11,"size_hint","","",3,N],[11,"partial_cmp","","",1,[[["self"],["name"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["name"]],["bool"]]],[11,"le","","",1,[[["self"],["name"]],["bool"]]],[11,"gt","","",1,[[["self"],["name"]],["bool"]]],[11,"ge","","",1,[[["self"],["name"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["mime"]],["option",["ordering"]]]],[11,"cmp","","",1,[[["self"],["name"]],["ordering"]]],[11,"cmp","","",0,[[["self"],["mime"]],["ordering"]]],[11,"eq","","",1,[[["self"],["name"]],["bool"]]],[11,"ne","","",1,[[["self"],["name"]],["bool"]]],[11,"eq","","",0,[[["self"],["mime"]],["bool"]]],[11,"eq","","",0,[[["self"],["str"]],["bool"]]],[11,"eq","","",1,[[["self"],["str"]],["bool"]]],[11,"as_ref","","",0,[[["self"]],["str"]]],[11,"as_ref","","",1,[[["self"]],["str"]]],[11,"clone","","",0,[[["self"]],["mime"]]],[11,"clone","","",1,[[["self"]],["name"]]],[11,"hash","","",1,N],[11,"hash","","",0,[[["self"],["t"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"from_str","","",0,[[["str"]],["result",["mime"]]]],[11,"description","","",2,[[["self"]],["str"]]]],"paths":[[3,"Mime"],[3,"Name"],[3,"FromStrError"],[3,"Params"]]};
searchIndex["mime_serde_shim"]={"doc":"Mime crate Serde shim","items":[[3,"Wrapper","mime_serde_shim","Wrapper type for `Mime` that provides Serde functionality while attempting to remain transparent.",N,N],[12,"0","","",0,N],[5,"serialize","","",N,[[["mime"],["s"]],["result"]]],[5,"deserialize","","",N,[[["d"]],["result",["mime"]]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"into","","",0,[[["self"]],["mime"]]],[11,"partial_cmp","","",0,[[["self"],["wrapper"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["wrapper"]],["bool"]]],[11,"le","","",0,[[["self"],["wrapper"]],["bool"]]],[11,"gt","","",0,[[["self"],["wrapper"]],["bool"]]],[11,"ge","","",0,[[["self"],["wrapper"]],["bool"]]],[11,"cmp","","",0,[[["self"],["wrapper"]],["ordering"]]],[11,"eq","","",0,[[["self"],["wrapper"]],["bool"]]],[11,"ne","","",0,[[["self"],["wrapper"]],["bool"]]],[11,"eq","","",0,[[["self"],["str"]],["bool"]]],[11,"eq","","",0,[[["self"],["mime"]],["bool"]]],[11,"from","","",0,[[["mime"]],["wrapper"]]],[11,"as_ref","","",0,[[["self"]],["str"]]],[11,"as_ref","","",0,[[["self"]],["mime"]]],[11,"clone","","",0,[[["self"]],["wrapper"]]],[11,"hash","","",0,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"deref","","",0,[[["self"]],["mime"]]],[11,"deref_mut","","",0,[[["self"]],["mime"]]],[11,"from_str","","",0,[[["str"]],["result",["wrapper"]]]],[11,"serialize","","",0,[[["self"],["s"]],["result"]]],[11,"deserialize","","",0,[[["d"]],["result",["wrapper"]]]]],"paths":[[3,"Wrapper"]]};
searchIndex["num_traits"]={"doc":"Numeric traits for generic mathematics","items":[[8,"Bounded","num_traits","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",0,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",0,[[],["self"]]],[8,"Float","","Generic trait for floating point numbers",N,N],[10,"nan","","Returns the `NaN` value.",1,[[],["self"]]],[10,"infinity","","Returns the infinite value.",1,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",1,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",1,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",1,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",1,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",1,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",1,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",1,[[["self"]],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",1,[[["self"]],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",1,[[["self"]],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",1,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",1,[[["self"]],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",1,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",1,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",1,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",1,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",1,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",1,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",1,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",1,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",1,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",1,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",1,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",1,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",1,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",1,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",1,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",1,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",1,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",1,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",1,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",1,[[["self"]],["self"]]],[11,"to_degrees","","Converts radians to degrees.",1,[[["self"]],["self"]]],[11,"to_radians","","Converts degrees to radians.",1,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",1,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",1,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",1,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",1,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",1,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",1,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",1,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",1,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",1,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",1,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",1,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",1,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",1,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",1,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",1,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",1,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",1,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",1,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",1,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",1,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",1,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",1,N],[8,"FloatConst","","",N,N],[10,"E","","Return Euler’s number.",2,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",2,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",2,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",2,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",2,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",2,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",2,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",2,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",2,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",2,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",2,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",2,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",2,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",2,[[],["self"]]],[10,"PI","","Return Archimedes’ constant.",2,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",2,[[],["self"]]],[8,"Zero","","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",3,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",4,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[8,"CheckedAdd","","Performs addition that returns `None` instead of wrapping around on overflow.",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",5,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",6,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",7,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",8,[[["self"],["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",N,N],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",9,[[["self"],["u32"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",N,N],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",10,[[["self"],["u32"]],["option"]]],[8,"WrappingAdd","","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of the type.",11,[[["self"],["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary of the type.",12,[[["self"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary of the type.",13,[[["self"],["self"]],["self"]]],[8,"Saturating","","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",14,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",14,[[["self"],["self"]],["self"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",15,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",15,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",15,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",15,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",15,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[5,"abs","","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",16,[[["self"]],["t"]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",17,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["f64"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",18,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",18,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",18,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",18,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",18,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",18,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",18,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",18,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",18,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",18,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",18,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",18,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",18,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",18,[[["self"]],["option",["f64"]]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",19,[[["t"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[8,"PrimInt","","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",20,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",20,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",20,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",20,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",20,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",20,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",20,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's endianness.",20,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's endianness.",20,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",20,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's endianness.",20,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",20,[[["self"],["u32"]],["self"]]],[5,"pow","","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[8,"Num","","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",N,N],[16,"FromStrRadixErr","","",21,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",21,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",N,N],[8,"NumRef","","The trait for `Num` types which also implement numeric operations taking the second operand by reference.",N,N],[8,"RefNum","","The trait for references which implement numeric operations, taking the second operand either by value or by reference.",N,N],[8,"NumAssignOps","","The trait for types implementing numeric assignment operators (like `+=`).",N,N],[8,"NumAssign","","The trait for `Num` types which also implement assignment operators.",N,N],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement assignment operations taking the second operand by reference.",N,N],[4,"FloatErrorKind","","",N,N],[13,"Empty","","",22,N],[13,"Invalid","","",22,N],[3,"ParseFloatError","","",N,N],[12,"kind","","",23,N],[5,"clamp","","A value bounded by a minimum and a maximum",N,[[["t"],["t"],["t"]],["t"]]],[0,"identities","","",N,N],[8,"Zero","num_traits::identities","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",3,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",4,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[0,"sign","num_traits","",N,N],[8,"Signed","num_traits::sign","Useful functions for signed numbers (i.e. numbers that can be negative).",N,N],[10,"abs","","Computes the absolute value.",15,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",15,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",15,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",15,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",15,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[5,"abs","","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[0,"ops","num_traits","",N,N],[0,"saturating","num_traits::ops","",N,N],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",14,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",14,[[["self"],["self"]],["self"]]],[0,"checked","num_traits::ops","",N,N],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping around on overflow.",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",5,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",6,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",7,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",8,[[["self"],["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",N,N],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",9,[[["self"],["u32"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",N,N],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",10,[[["self"],["u32"]],["option"]]],[0,"wrapping","num_traits::ops","",N,N],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of the type.",11,[[["self"],["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary of the type.",12,[[["self"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary of the type.",13,[[["self"],["self"]],["self"]]],[0,"bounds","num_traits","",N,N],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",0,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",0,[[],["self"]]],[0,"float","num_traits","",N,N],[8,"Float","num_traits::float","Generic trait for floating point numbers",N,N],[10,"nan","","Returns the `NaN` value.",1,[[],["self"]]],[10,"infinity","","Returns the infinite value.",1,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",1,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",1,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can represent.",1,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",1,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",1,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",1,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",1,[[["self"]],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",1,[[["self"]],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",1,[[["self"]],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",1,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",1,[[["self"]],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",1,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",1,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",1,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",1,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",1,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",1,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",1,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",1,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",1,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",1,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",1,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",1,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",1,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",1,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",1,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",1,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",1,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",1,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",1,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",1,[[["self"]],["self"]]],[11,"to_degrees","","Converts radians to degrees.",1,[[["self"]],["self"]]],[11,"to_radians","","Converts degrees to radians.",1,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",1,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",1,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",1,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",1,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",1,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",1,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",1,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",1,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",1,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",1,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",1,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",1,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",1,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",1,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",1,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",1,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",1,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",1,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",1,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",1,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",1,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",1,N],[8,"FloatConst","","",N,N],[10,"E","","Return Euler’s number.",2,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",2,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",2,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",2,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",2,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",2,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",2,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",2,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",2,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",2,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",2,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",2,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",2,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",2,[[],["self"]]],[10,"PI","","Return Archimedes’ constant.",2,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",2,[[],["self"]]],[0,"real","num_traits","",N,N],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have floating-point-specific characteristics such as NaN and infinity.",N,N],[10,"min_value","","Returns the smallest finite value that this type can represent.",24,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",24,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",24,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can represent.",24,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",24,[[["self"]],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",24,[[["self"]],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",24,[[["self"]],["self"]]],[10,"trunc","","Return the integer part of a number.",24,[[["self"]],["self"]]],[10,"fract","","Returns the fractional part of a number.",24,[[["self"]],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",24,[[["self"]],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",24,[[["self"]],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and with newer versions of Rust `f64::NAN`.",24,[[["self"]],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.",24,[[["self"]],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error, yielding a more accurate result than an unfused multiply-add.",24,[[["self"],["self"],["self"]],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",24,[[["self"]],["self"]]],[10,"powi","","Raise a number to an integer power.",24,[[["self"],["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",24,[[["self"],["self"]],["self"]]],[10,"sqrt","","Take the square root of a number.",24,[[["self"]],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",24,[[["self"]],["self"]]],[10,"exp2","","Returns `2^(self)`.",24,[[["self"]],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",24,[[["self"]],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",24,[[["self"],["self"]],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",24,[[["self"]],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",24,[[["self"]],["self"]]],[10,"to_degrees","","Converts radians to degrees.",24,[[["self"]],["self"]]],[10,"to_radians","","Converts degrees to radians.",24,[[["self"]],["self"]]],[10,"max","","Returns the maximum of the two numbers.",24,[[["self"],["self"]],["self"]]],[10,"min","","Returns the minimum of the two numbers.",24,[[["self"],["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",24,[[["self"],["self"]],["self"]]],[10,"cbrt","","Take the cubic root of a number.",24,[[["self"]],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",24,[[["self"],["self"]],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",24,[[["self"]],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",24,[[["self"]],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",24,[[["self"]],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",24,[[["self"]],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",24,[[["self"]],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",24,[[["self"]],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",24,[[["self"],["self"]],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",24,N],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",24,[[["self"]],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",24,[[["self"]],["self"]]],[10,"sinh","","Hyperbolic sine function.",24,[[["self"]],["self"]]],[10,"cosh","","Hyperbolic cosine function.",24,[[["self"]],["self"]]],[10,"tanh","","Hyperbolic tangent function.",24,[[["self"]],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",24,[[["self"]],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",24,[[["self"]],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",24,[[["self"]],["self"]]],[0,"cast","num_traits","",N,N],[8,"AsPrimitive","num_traits::cast","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",16,[[["self"]],["t"]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, then `None` is returned.",17,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, then `None` is returned.",17,[[["f64"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",18,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",18,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",18,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",18,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",18,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",18,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",18,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",18,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",18,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",18,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",18,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",18,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",18,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",18,[[["self"]],["option",["f64"]]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",19,[[["t"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[0,"int","num_traits","",N,N],[8,"PrimInt","num_traits::int","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",20,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",20,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",20,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",20,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",20,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",20,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",20,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",20,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's endianness.",20,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's endianness.",20,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",20,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's endianness.",20,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",20,[[["self"],["u32"]],["self"]]],[0,"pow","num_traits","",N,N],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation by squaring.",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",N,[[["t"],["usize"]],["option"]]],[11,"into","num_traits","",22,[[["self"]],["u"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"to_string","","",23,[[["self"]],["string"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result",["error"]]]]],"paths":[[8,"Bounded"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"WrappingAdd"],[8,"WrappingMul"],[8,"WrappingSub"],[8,"Saturating"],[8,"Signed"],[8,"AsPrimitive"],[8,"FromPrimitive"],[8,"ToPrimitive"],[8,"NumCast"],[8,"PrimInt"],[8,"Num"],[4,"FloatErrorKind"],[3,"ParseFloatError"],[8,"Real"]]};
searchIndex["serde"]={"doc":"Serde","items":[[0,"de","serde","Generic data structure deserialization framework.",N,N],[3,"IgnoredAny","serde::de","An efficient way of discarding data from a deserializer.",N,N],[4,"Unexpected","","`Unexpected` represents an unexpected invocation of any one of the `Visitor` trait methods.",N,N],[13,"Bool","","The input contained a boolean value that was not expected.",0,N],[13,"Unsigned","","The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that was not expected.",0,N],[13,"Signed","","The input contained a signed integer `i8`, `i16`, `i32` or `i64` that was not expected.",0,N],[13,"Float","","The input contained a floating point `f32` or `f64` that was not expected.",0,N],[13,"Char","","The input contained a `char` that was not expected.",0,N],[13,"Str","","The input contained a `&str` or `String` that was not expected.",0,N],[13,"Bytes","","The input contained a `&[u8]` or `Vec<u8>` that was not expected.",0,N],[13,"Unit","","The input contained a unit `()` that was not expected.",0,N],[13,"Option","","The input contained an `Option<T>` that was not expected.",0,N],[13,"NewtypeStruct","","The input contained a newtype struct that was not expected.",0,N],[13,"Seq","","The input contained a sequence that was not expected.",0,N],[13,"Map","","The input contained a map that was not expected.",0,N],[13,"Enum","","The input contained an enum that was not expected.",0,N],[13,"UnitVariant","","The input contained a unit variant that was not expected.",0,N],[13,"NewtypeVariant","","The input contained a newtype variant that was not expected.",0,N],[13,"TupleVariant","","The input contained a tuple variant that was not expected.",0,N],[13,"StructVariant","","The input contained a struct variant that was not expected.",0,N],[13,"Other","","A message stating what uncategorized thing the input contained that was not expected.",0,N],[0,"value","","Building blocks for deserializing basic values using the `IntoDeserializer` trait.",N,N],[3,"Error","serde::de::value","A minimal representation of all possible errors that can occur using the `IntoDeserializer` trait.",N,N],[3,"UnitDeserializer","","A deserializer holding a `()`.",N,N],[3,"BoolDeserializer","","A deserializer holding a `bool`.",N,N],[3,"I8Deserializer","","A deserializer holding an `i8`.",N,N],[3,"I16Deserializer","","A deserializer holding an `i16`.",N,N],[3,"I32Deserializer","","A deserializer holding an `i32`.",N,N],[3,"I64Deserializer","","A deserializer holding an `i64`.",N,N],[3,"IsizeDeserializer","","A deserializer holding an `isize`.",N,N],[3,"U8Deserializer","","A deserializer holding a `u8`.",N,N],[3,"U16Deserializer","","A deserializer holding a `u16`.",N,N],[3,"U64Deserializer","","A deserializer holding a `u64`.",N,N],[3,"UsizeDeserializer","","A deserializer holding a `usize`.",N,N],[3,"F32Deserializer","","A deserializer holding an `f32`.",N,N],[3,"F64Deserializer","","A deserializer holding an `f64`.",N,N],[3,"CharDeserializer","","A deserializer holding a `char`.",N,N],[3,"I128Deserializer","","A deserializer holding an `i128`.",N,N],[3,"U128Deserializer","","A deserializer holding a `u128`.",N,N],[3,"U32Deserializer","","A deserializer holding a `u32`.",N,N],[3,"StrDeserializer","","A deserializer holding a `&str`.",N,N],[3,"BorrowedStrDeserializer","","A deserializer holding a `&str` with a lifetime tied to another deserializer.",N,N],[3,"StringDeserializer","","A deserializer holding a `String`.",N,N],[3,"CowStrDeserializer","","A deserializer holding a `Cow<str>`.",N,N],[3,"BorrowedBytesDeserializer","","A deserializer holding a `&[u8]` with a lifetime tied to another deserializer.",N,N],[3,"SeqDeserializer","","A deserializer that iterates over a sequence.",N,N],[3,"SeqAccessDeserializer","","A deserializer holding a `SeqAccess`.",N,N],[3,"MapDeserializer","","A deserializer that iterates over a map.",N,N],[3,"MapAccessDeserializer","","A deserializer holding a `MapAccess`.",N,N],[11,"new","","Create a new borrowed deserializer from the given string.",1,[[["str"]],["borrowedstrdeserializer"]]],[11,"new","","Create a new borrowed deserializer from the given byte slice.",2,N],[11,"new","","Construct a new `SeqDeserializer<I, E>`.",3,[[["i"]],["self"]]],[11,"end","","Check for remaining elements after passing a `SeqDeserializer` to `Visitor::visit_seq`.",3,[[["self"]],["result"]]],[11,"new","","Construct a new `SeqAccessDeserializer<A>`.",4,[[["a"]],["self"]]],[11,"new","","Construct a new `MapDeserializer<I, E>`.",5,[[["i"]],["self"]]],[11,"end","","Check for remaining elements after passing a `MapDeserializer` to `Visitor::visit_map`.",5,[[["self"]],["result"]]],[11,"new","","Construct a new `MapAccessDeserializer<A>`.",6,[[["a"]],["self"]]],[8,"Error","serde::de","The `Error` trait allows `Deserialize` implementations to create descriptive error messages belonging to the `Deserializer` against which they are currently running.",N,N],[10,"custom","","Raised when there is general error when deserializing a type.",7,[[["t"]],["self"]]],[11,"invalid_type","","Raised when a `Deserialize` receives a type different from what it was expecting.",7,[[["unexpected"],["expected"]],["self"]]],[11,"invalid_value","","Raised when a `Deserialize` receives a value of the right type but that is wrong for some other reason.",7,[[["unexpected"],["expected"]],["self"]]],[11,"invalid_length","","Raised when deserializing a sequence or map and the input data contains too many or too few elements.",7,[[["usize"],["expected"]],["self"]]],[11,"unknown_variant","","Raised when a `Deserialize` enum type received a variant with an unrecognized name.",7,N],[11,"unknown_field","","Raised when a `Deserialize` struct type received a field with an unrecognized name.",7,N],[11,"missing_field","","Raised when a `Deserialize` struct type expected to receive a required field with a particular name but that field was not present in the input.",7,[[["str"]],["self"]]],[11,"duplicate_field","","Raised when a `Deserialize` struct type received more than one of the same field.",7,[[["str"]],["self"]]],[8,"Expected","","`Expected` represents an explanation of what data a `Visitor` was expecting to receive.",N,N],[10,"fmt","","Format an explanation of what data was being expected. Same signature as the `Display` and `Debug` traits.",8,[[["self"],["formatter"]],["result"]]],[8,"Deserialize","","A data structure that can be deserialized from any data format supported by Serde.",N,N],[10,"deserialize","","Deserialize this value from the given Serde deserializer.",9,[[["d"]],["result"]]],[8,"DeserializeOwned","","A data structure that can be deserialized without borrowing any data from the deserializer.",N,N],[8,"DeserializeSeed","","`DeserializeSeed` is the stateful form of the `Deserialize` trait. If you ever find yourself looking for a way to pass data into a `Deserialize` impl, this trait is the way to do it.",N,N],[16,"Value","","The type produced by using this seed.",10,N],[10,"deserialize","","Equivalent to the more common `Deserialize::deserialize` method, except with some initial piece of data (the seed) passed in.",10,[[["self"],["d"]],["result"]]],[8,"Deserializer","","A data format that can deserialize any data structure supported by Serde.",N,N],[16,"Error","","The error type that can be returned if some error occurs during deserialization.",11,N],[10,"deserialize_any","","Require the `Deserializer` to figure out how to drive the visitor based on what data type is in the input.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_bool","","Hint that the `Deserialize` type is expecting a `bool` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i8","","Hint that the `Deserialize` type is expecting an `i8` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i16","","Hint that the `Deserialize` type is expecting an `i16` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i32","","Hint that the `Deserialize` type is expecting an `i32` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i64","","Hint that the `Deserialize` type is expecting an `i64` value.",11,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","Hint that the `Deserialize` type is expecting an `i128` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u8","","Hint that the `Deserialize` type is expecting a `u8` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u16","","Hint that the `Deserialize` type is expecting a `u16` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u32","","Hint that the `Deserialize` type is expecting a `u32` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u64","","Hint that the `Deserialize` type is expecting a `u64` value.",11,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","Hint that the `Deserialize` type is expecting an `u128` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_f32","","Hint that the `Deserialize` type is expecting a `f32` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_f64","","Hint that the `Deserialize` type is expecting a `f64` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_char","","Hint that the `Deserialize` type is expecting a `char` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_str","","Hint that the `Deserialize` type is expecting a string value and does not benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_string","","Hint that the `Deserialize` type is expecting a string value and would benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_bytes","","Hint that the `Deserialize` type is expecting a byte array and does not benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_byte_buf","","Hint that the `Deserialize` type is expecting a byte array and would benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_option","","Hint that the `Deserialize` type is expecting an optional value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_unit","","Hint that the `Deserialize` type is expecting a unit value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_unit_struct","","Hint that the `Deserialize` type is expecting a unit struct with a particular name.",11,[[["self"],["str"],["v"]],["result"]]],[10,"deserialize_newtype_struct","","Hint that the `Deserialize` type is expecting a newtype struct with a particular name.",11,[[["self"],["str"],["v"]],["result"]]],[10,"deserialize_seq","","Hint that the `Deserialize` type is expecting a sequence of values.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_tuple","","Hint that the `Deserialize` type is expecting a sequence of values and knows how many values there are without looking at the serialized data.",11,[[["self"],["usize"],["v"]],["result"]]],[10,"deserialize_tuple_struct","","Hint that the `Deserialize` type is expecting a tuple struct with a particular name and number of fields.",11,[[["self"],["str"],["usize"],["v"]],["result"]]],[10,"deserialize_map","","Hint that the `Deserialize` type is expecting a map of key-value pairs.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_struct","","Hint that the `Deserialize` type is expecting a struct with a particular name and fields.",11,N],[10,"deserialize_enum","","Hint that the `Deserialize` type is expecting an enum value with a particular name and possible variants.",11,N],[10,"deserialize_identifier","","Hint that the `Deserialize` type is expecting the name of a struct field or the discriminant of an enum variant.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_ignored_any","","Hint that the `Deserialize` type needs to deserialize a value whose type doesn't matter because it is ignored.",11,[[["self"],["v"]],["result"]]],[11,"is_human_readable","","Determine whether `Deserialize` implementations should expect to deserialize their human-readable form.",11,[[["self"]],["bool"]]],[8,"Visitor","","This trait represents a visitor that walks through a deserializer.",N,N],[16,"Value","","The value produced by this visitor.",12,N],[10,"expecting","","Format a message stating what data this Visitor expects to receive.",12,[[["self"],["formatter"]],["result"]]],[11,"visit_bool","","The input contains a boolean.",12,[[["self"],["bool"]],["result"]]],[11,"visit_i8","","The input contains an `i8`.",12,[[["self"],["i8"]],["result"]]],[11,"visit_i16","","The input contains an `i16`.",12,[[["self"],["i16"]],["result"]]],[11,"visit_i32","","The input contains an `i32`.",12,[[["self"],["i32"]],["result"]]],[11,"visit_i64","","The input contains an `i64`.",12,[[["self"],["i64"]],["result"]]],[11,"visit_i128","","The input contains a `i128`.",12,[[["self"],["i128"]],["result"]]],[11,"visit_u8","","The input contains a `u8`.",12,[[["self"],["u8"]],["result"]]],[11,"visit_u16","","The input contains a `u16`.",12,[[["self"],["u16"]],["result"]]],[11,"visit_u32","","The input contains a `u32`.",12,[[["self"],["u32"]],["result"]]],[11,"visit_u64","","The input contains a `u64`.",12,[[["self"],["u64"]],["result"]]],[11,"visit_u128","","The input contains a `u128`.",12,[[["self"],["u128"]],["result"]]],[11,"visit_f32","","The input contains an `f32`.",12,[[["self"],["f32"]],["result"]]],[11,"visit_f64","","The input contains an `f64`.",12,[[["self"],["f64"]],["result"]]],[11,"visit_char","","The input contains a `char`.",12,[[["self"],["char"]],["result"]]],[11,"visit_str","","The input contains a string. The lifetime of the string is ephemeral and it may be destroyed after this method returns.",12,[[["self"],["str"]],["result"]]],[11,"visit_borrowed_str","","The input contains a string that lives at least as long as the `Deserializer`.",12,[[["self"],["str"]],["result"]]],[11,"visit_string","","The input contains a string and ownership of the string is being given to the `Visitor`.",12,[[["self"],["string"]],["result"]]],[11,"visit_bytes","","The input contains a byte array. The lifetime of the byte array is ephemeral and it may be destroyed after this method returns.",12,N],[11,"visit_borrowed_bytes","","The input contains a byte array that lives at least as long as the `Deserializer`.",12,N],[11,"visit_byte_buf","","The input contains a byte array and ownership of the byte array is being given to the `Visitor`.",12,[[["self"],["vec",["u8"]]],["result"]]],[11,"visit_none","","The input contains an optional that is absent.",12,[[["self"]],["result"]]],[11,"visit_some","","The input contains an optional that is present.",12,[[["self"],["d"]],["result"]]],[11,"visit_unit","","The input contains a unit `()`.",12,[[["self"]],["result"]]],[11,"visit_newtype_struct","","The input contains a newtype struct.",12,[[["self"],["d"]],["result"]]],[11,"visit_seq","","The input contains a sequence of elements.",12,[[["self"],["a"]],["result"]]],[11,"visit_map","","The input contains a key-value map.",12,[[["self"],["a"]],["result"]]],[11,"visit_enum","","The input contains an enum.",12,[[["self"],["a"]],["result"]]],[8,"SeqAccess","","Provides a `Visitor` access to each element of a sequence in the input.",N,N],[16,"Error","","The error type that can be returned if some error occurs during deserialization.",13,N],[10,"next_element_seed","","This returns `Ok(Some(value))` for the next value in the sequence, or `Ok(None)` if there are no more remaining items.",13,[[["self"],["t"]],["result",["option"]]]],[11,"next_element","","This returns `Ok(Some(value))` for the next value in the sequence, or `Ok(None)` if there are no more remaining items.",13,[[["self"]],["result",["option"]]]],[11,"size_hint","","Returns the number of elements remaining in the sequence, if known.",13,[[["self"]],["option",["usize"]]]],[8,"MapAccess","","Provides a `Visitor` access to each entry of a map in the input.",N,N],[16,"Error","","The error type that can be returned if some error occurs during deserialization.",14,N],[10,"next_key_seed","","This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)` if there are no more remaining entries.",14,[[["self"],["k"]],["result",["option"]]]],[10,"next_value_seed","","This returns a `Ok(value)` for the next value in the map.",14,[[["self"],["v"]],["result"]]],[11,"next_entry_seed","","This returns `Ok(Some((key, value)))` for the next (key-value) pair in the map, or `Ok(None)` if there are no more remaining items.",14,[[["self"],["k"],["v"]],["result",["option"]]]],[11,"next_key","","This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)` if there are no more remaining entries.",14,[[["self"]],["result",["option"]]]],[11,"next_value","","This returns a `Ok(value)` for the next value in the map.",14,[[["self"]],["result"]]],[11,"next_entry","","This returns `Ok(Some((key, value)))` for the next (key-value) pair in the map, or `Ok(None)` if there are no more remaining items.",14,[[["self"]],["result",["option"]]]],[11,"size_hint","","Returns the number of entries remaining in the map, if known.",14,[[["self"]],["option",["usize"]]]],[8,"EnumAccess","","Provides a `Visitor` access to the data of an enum in the input.",N,N],[16,"Error","","The error type that can be returned if some error occurs during deserialization.",15,N],[16,"Variant","","The `Visitor` that will be used to deserialize the content of the enum variant.",15,N],[10,"variant_seed","","`variant` is called to identify which variant to deserialize.",15,[[["self"],["v"]],["result"]]],[11,"variant","","`variant` is called to identify which variant to deserialize.",15,[[["self"]],["result"]]],[8,"VariantAccess","","`VariantAccess` is a visitor that is created by the `Deserializer` and passed to the `Deserialize` to deserialize the content of a particular enum variant.",N,N],[16,"Error","","The error type that can be returned if some error occurs during deserialization. Must match the error type of our `EnumAccess`.",16,N],[10,"unit_variant","","Called when deserializing a variant with no values.",16,[[["self"]],["result"]]],[10,"newtype_variant_seed","","Called when deserializing a variant with a single value.",16,[[["self"],["t"]],["result"]]],[11,"newtype_variant","","Called when deserializing a variant with a single value.",16,[[["self"]],["result"]]],[10,"tuple_variant","","Called when deserializing a tuple-like variant.",16,[[["self"],["usize"],["v"]],["result"]]],[10,"struct_variant","","Called when deserializing a struct-like variant.",16,N],[8,"IntoDeserializer","","Converts an existing value into a `Deserializer` from which other values can be deserialized.",N,N],[16,"Deserializer","","The type of the deserializer being converted into.",17,N],[10,"into_deserializer","","Convert this value into a deserializer.",17,N],[0,"ser","serde","Generic data structure serialization framework.",N,N],[3,"Impossible","serde::ser","Helper type for implementing a `Serializer` that does not support serializing one of the compound types.",N,N],[8,"Error","","Trait used by `Serialize` implementations to generically construct errors belonging to the `Serializer` against which they are currently running.",N,N],[10,"custom","","Used when a [`Serialize`] implementation encounters any error while serializing a type.",18,[[["t"]],["self"]]],[8,"Serialize","","A data structure that can be serialized into any data format supported by Serde.",N,N],[10,"serialize","","Serialize this value into the given Serde serializer.",19,[[["self"],["s"]],["result"]]],[8,"Serializer","","A data format that can serialize any data structure supported by Serde.",N,N],[16,"Ok","","The output type produced by this `Serializer` during successful serialization. Most serializers that produce text or binary output should set `Ok = ()` and serialize into an [`io::Write`] or buffer contained within the `Serializer` instance. Serializers that build in-memory data structures may be simplified by using `Ok` to propagate the data structure around.",20,N],[16,"Error","","The error type when some error occurs during serialization.",20,N],[16,"SerializeSeq","","Type returned from [`serialize_seq`] for serializing the content of the sequence.",20,N],[16,"SerializeTuple","","Type returned from [`serialize_tuple`] for serializing the content of the tuple.",20,N],[16,"SerializeTupleStruct","","Type returned from [`serialize_tuple_struct`] for serializing the content of the tuple struct.",20,N],[16,"SerializeTupleVariant","","Type returned from [`serialize_tuple_variant`] for serializing the content of the tuple variant.",20,N],[16,"SerializeMap","","Type returned from [`serialize_map`] for serializing the content of the map.",20,N],[16,"SerializeStruct","","Type returned from [`serialize_struct`] for serializing the content of the struct.",20,N],[16,"SerializeStructVariant","","Type returned from [`serialize_struct_variant`] for serializing the content of the struct variant.",20,N],[10,"serialize_bool","","Serialize a `bool` value.",20,[[["self"],["bool"]],["result"]]],[10,"serialize_i8","","Serialize an `i8` value.",20,[[["self"],["i8"]],["result"]]],[10,"serialize_i16","","Serialize an `i16` value.",20,[[["self"],["i16"]],["result"]]],[10,"serialize_i32","","Serialize an `i32` value.",20,[[["self"],["i32"]],["result"]]],[10,"serialize_i64","","Serialize an `i64` value.",20,[[["self"],["i64"]],["result"]]],[11,"serialize_i128","","Serialize an `i128` value.",20,[[["self"],["i128"]],["result"]]],[10,"serialize_u8","","Serialize a `u8` value.",20,[[["self"],["u8"]],["result"]]],[10,"serialize_u16","","Serialize a `u16` value.",20,[[["self"],["u16"]],["result"]]],[10,"serialize_u32","","Serialize a `u32` value.",20,[[["self"],["u32"]],["result"]]],[10,"serialize_u64","","Serialize a `u64` value.",20,[[["self"],["u64"]],["result"]]],[11,"serialize_u128","","Serialize a `u128` value.",20,[[["self"],["u128"]],["result"]]],[10,"serialize_f32","","Serialize an `f32` value.",20,[[["self"],["f32"]],["result"]]],[10,"serialize_f64","","Serialize an `f64` value.",20,[[["self"],["f64"]],["result"]]],[10,"serialize_char","","Serialize a character.",20,[[["self"],["char"]],["result"]]],[10,"serialize_str","","Serialize a `&str`.",20,[[["self"],["str"]],["result"]]],[10,"serialize_bytes","","Serialize a chunk of raw byte data.",20,N],[10,"serialize_none","","Serialize a [`None`] value.",20,[[["self"]],["result"]]],[10,"serialize_some","","Serialize a [`Some(T)`] value.",20,[[["self"],["t"]],["result"]]],[10,"serialize_unit","","Serialize a `()` value.",20,[[["self"]],["result"]]],[10,"serialize_unit_struct","","Serialize a unit struct like `struct Unit` or `PhantomData<T>`.",20,[[["self"],["str"]],["result"]]],[10,"serialize_unit_variant","","Serialize a unit variant like `E::A` in `enum E { A, B }`.",20,[[["self"],["str"],["u32"],["str"]],["result"]]],[10,"serialize_newtype_struct","","Serialize a newtype struct like `struct Millimeters(u8)`.",20,[[["self"],["str"],["t"]],["result"]]],[10,"serialize_newtype_variant","","Serialize a newtype variant like `E::N` in `enum E { N(u8) }`.",20,[[["self"],["str"],["u32"],["str"],["t"]],["result"]]],[10,"serialize_seq","","Begin to serialize a variably sized sequence. This call must be followed by zero or more calls to `serialize_element`, then a call to `end`.",20,[[["self"],["option",["usize"]]],["result"]]],[10,"serialize_tuple","","Begin to serialize a statically sized sequence whose length will be known at deserialization time without looking at the serialized data. This call must be followed by zero or more calls to `serialize_element`, then a call to `end`.",20,[[["self"],["usize"]],["result"]]],[10,"serialize_tuple_struct","","Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["usize"]],["result"]]],[10,"serialize_tuple_variant","","Begin to serialize a tuple variant like `E::T` in `enum E { T(u8, u8) }`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["u32"],["str"],["usize"]],["result"]]],[10,"serialize_map","","Begin to serialize a map. This call must be followed by zero or more calls to `serialize_key` and `serialize_value`, then a call to `end`.",20,[[["self"],["option",["usize"]]],["result"]]],[10,"serialize_struct","","Begin to serialize a struct like `struct Rgb { r: u8, g: u8, b: u8 }`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["usize"]],["result"]]],[10,"serialize_struct_variant","","Begin to serialize a struct variant like `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["u32"],["str"],["usize"]],["result"]]],[11,"collect_seq","","Collect an iterator as a sequence.",20,[[["self"],["i"]],["result"]]],[11,"collect_map","","Collect an iterator as a map.",20,[[["self"],["i"]],["result"]]],[11,"collect_str","","Serialize a string produced by an implementation of `Display`.",20,[[["self"],["t"]],["result"]]],[11,"is_human_readable","","Determine whether `Serialize` implementations should serialize in human-readable form.",20,[[["self"]],["bool"]]],[8,"SerializeSeq","","Returned from `Serializer::serialize_seq`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",21,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",21,N],[10,"serialize_element","","Serialize a sequence element.",21,[[["self"],["t"]],["result"]]],[10,"end","","Finish serializing a sequence.",21,[[["self"]],["result"]]],[8,"SerializeTuple","","Returned from `Serializer::serialize_tuple`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",22,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",22,N],[10,"serialize_element","","Serialize a tuple element.",22,[[["self"],["t"]],["result"]]],[10,"end","","Finish serializing a tuple.",22,[[["self"]],["result"]]],[8,"SerializeTupleStruct","","Returned from `Serializer::serialize_tuple_struct`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",23,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",23,N],[10,"serialize_field","","Serialize a tuple struct field.",23,[[["self"],["t"]],["result"]]],[10,"end","","Finish serializing a tuple struct.",23,[[["self"]],["result"]]],[8,"SerializeTupleVariant","","Returned from `Serializer::serialize_tuple_variant`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",24,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",24,N],[10,"serialize_field","","Serialize a tuple variant field.",24,[[["self"],["t"]],["result"]]],[10,"end","","Finish serializing a tuple variant.",24,[[["self"]],["result"]]],[8,"SerializeMap","","Returned from `Serializer::serialize_map`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",25,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",25,N],[10,"serialize_key","","Serialize a map key.",25,[[["self"],["t"]],["result"]]],[10,"serialize_value","","Serialize a map value.",25,[[["self"],["t"]],["result"]]],[11,"serialize_entry","","Serialize a map entry consisting of a key and a value.",25,[[["self"],["k"],["v"]],["result"]]],[10,"end","","Finish serializing a map.",25,[[["self"]],["result"]]],[8,"SerializeStruct","","Returned from `Serializer::serialize_struct`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",26,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",26,N],[10,"serialize_field","","Serialize a struct field.",26,[[["self"],["str"],["t"]],["result"]]],[11,"skip_field","","Indicate that a struct field has been skipped.",26,[[["self"],["str"]],["result"]]],[10,"end","","Finish serializing a struct.",26,[[["self"]],["result"]]],[8,"SerializeStructVariant","","Returned from `Serializer::serialize_struct_variant`.",N,N],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",27,N],[16,"Error","","Must match the `Error` type of our `Serializer`.",27,N],[10,"serialize_field","","Serialize a struct variant field.",27,[[["self"],["str"],["t"]],["result"]]],[11,"skip_field","","Indicate that a struct variant field has been skipped.",27,[[["self"],["str"]],["result"]]],[10,"end","","Finish serializing a struct variant.",27,[[["self"]],["result"]]],[8,"Deserialize","serde","A data structure that can be deserialized from any data format supported by Serde.",N,N],[10,"deserialize","","Deserialize this value from the given Serde deserializer.",9,[[["d"]],["result"]]],[8,"Deserializer","","A data format that can deserialize any data structure supported by Serde.",N,N],[16,"Error","","The error type that can be returned if some error occurs during deserialization.",11,N],[10,"deserialize_any","","Require the `Deserializer` to figure out how to drive the visitor based on what data type is in the input.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_bool","","Hint that the `Deserialize` type is expecting a `bool` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i8","","Hint that the `Deserialize` type is expecting an `i8` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i16","","Hint that the `Deserialize` type is expecting an `i16` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i32","","Hint that the `Deserialize` type is expecting an `i32` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_i64","","Hint that the `Deserialize` type is expecting an `i64` value.",11,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","Hint that the `Deserialize` type is expecting an `i128` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u8","","Hint that the `Deserialize` type is expecting a `u8` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u16","","Hint that the `Deserialize` type is expecting a `u16` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u32","","Hint that the `Deserialize` type is expecting a `u32` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_u64","","Hint that the `Deserialize` type is expecting a `u64` value.",11,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","Hint that the `Deserialize` type is expecting an `u128` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_f32","","Hint that the `Deserialize` type is expecting a `f32` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_f64","","Hint that the `Deserialize` type is expecting a `f64` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_char","","Hint that the `Deserialize` type is expecting a `char` value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_str","","Hint that the `Deserialize` type is expecting a string value and does not benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_string","","Hint that the `Deserialize` type is expecting a string value and would benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_bytes","","Hint that the `Deserialize` type is expecting a byte array and does not benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_byte_buf","","Hint that the `Deserialize` type is expecting a byte array and would benefit from taking ownership of buffered data owned by the `Deserializer`.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_option","","Hint that the `Deserialize` type is expecting an optional value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_unit","","Hint that the `Deserialize` type is expecting a unit value.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_unit_struct","","Hint that the `Deserialize` type is expecting a unit struct with a particular name.",11,[[["self"],["str"],["v"]],["result"]]],[10,"deserialize_newtype_struct","","Hint that the `Deserialize` type is expecting a newtype struct with a particular name.",11,[[["self"],["str"],["v"]],["result"]]],[10,"deserialize_seq","","Hint that the `Deserialize` type is expecting a sequence of values.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_tuple","","Hint that the `Deserialize` type is expecting a sequence of values and knows how many values there are without looking at the serialized data.",11,[[["self"],["usize"],["v"]],["result"]]],[10,"deserialize_tuple_struct","","Hint that the `Deserialize` type is expecting a tuple struct with a particular name and number of fields.",11,[[["self"],["str"],["usize"],["v"]],["result"]]],[10,"deserialize_map","","Hint that the `Deserialize` type is expecting a map of key-value pairs.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_struct","","Hint that the `Deserialize` type is expecting a struct with a particular name and fields.",11,N],[10,"deserialize_enum","","Hint that the `Deserialize` type is expecting an enum value with a particular name and possible variants.",11,N],[10,"deserialize_identifier","","Hint that the `Deserialize` type is expecting the name of a struct field or the discriminant of an enum variant.",11,[[["self"],["v"]],["result"]]],[10,"deserialize_ignored_any","","Hint that the `Deserialize` type needs to deserialize a value whose type doesn't matter because it is ignored.",11,[[["self"],["v"]],["result"]]],[11,"is_human_readable","","Determine whether `Deserialize` implementations should expect to deserialize their human-readable form.",11,[[["self"]],["bool"]]],[8,"Serialize","","A data structure that can be serialized into any data format supported by Serde.",N,N],[10,"serialize","","Serialize this value into the given Serde serializer.",19,[[["self"],["s"]],["result"]]],[8,"Serializer","","A data format that can serialize any data structure supported by Serde.",N,N],[16,"Ok","","The output type produced by this `Serializer` during successful serialization. Most serializers that produce text or binary output should set `Ok = ()` and serialize into an [`io::Write`] or buffer contained within the `Serializer` instance. Serializers that build in-memory data structures may be simplified by using `Ok` to propagate the data structure around.",20,N],[16,"Error","","The error type when some error occurs during serialization.",20,N],[16,"SerializeSeq","","Type returned from [`serialize_seq`] for serializing the content of the sequence.",20,N],[16,"SerializeTuple","","Type returned from [`serialize_tuple`] for serializing the content of the tuple.",20,N],[16,"SerializeTupleStruct","","Type returned from [`serialize_tuple_struct`] for serializing the content of the tuple struct.",20,N],[16,"SerializeTupleVariant","","Type returned from [`serialize_tuple_variant`] for serializing the content of the tuple variant.",20,N],[16,"SerializeMap","","Type returned from [`serialize_map`] for serializing the content of the map.",20,N],[16,"SerializeStruct","","Type returned from [`serialize_struct`] for serializing the content of the struct.",20,N],[16,"SerializeStructVariant","","Type returned from [`serialize_struct_variant`] for serializing the content of the struct variant.",20,N],[10,"serialize_bool","","Serialize a `bool` value.",20,[[["self"],["bool"]],["result"]]],[10,"serialize_i8","","Serialize an `i8` value.",20,[[["self"],["i8"]],["result"]]],[10,"serialize_i16","","Serialize an `i16` value.",20,[[["self"],["i16"]],["result"]]],[10,"serialize_i32","","Serialize an `i32` value.",20,[[["self"],["i32"]],["result"]]],[10,"serialize_i64","","Serialize an `i64` value.",20,[[["self"],["i64"]],["result"]]],[11,"serialize_i128","","Serialize an `i128` value.",20,[[["self"],["i128"]],["result"]]],[10,"serialize_u8","","Serialize a `u8` value.",20,[[["self"],["u8"]],["result"]]],[10,"serialize_u16","","Serialize a `u16` value.",20,[[["self"],["u16"]],["result"]]],[10,"serialize_u32","","Serialize a `u32` value.",20,[[["self"],["u32"]],["result"]]],[10,"serialize_u64","","Serialize a `u64` value.",20,[[["self"],["u64"]],["result"]]],[11,"serialize_u128","","Serialize a `u128` value.",20,[[["self"],["u128"]],["result"]]],[10,"serialize_f32","","Serialize an `f32` value.",20,[[["self"],["f32"]],["result"]]],[10,"serialize_f64","","Serialize an `f64` value.",20,[[["self"],["f64"]],["result"]]],[10,"serialize_char","","Serialize a character.",20,[[["self"],["char"]],["result"]]],[10,"serialize_str","","Serialize a `&str`.",20,[[["self"],["str"]],["result"]]],[10,"serialize_bytes","","Serialize a chunk of raw byte data.",20,N],[10,"serialize_none","","Serialize a [`None`] value.",20,[[["self"]],["result"]]],[10,"serialize_some","","Serialize a [`Some(T)`] value.",20,[[["self"],["t"]],["result"]]],[10,"serialize_unit","","Serialize a `()` value.",20,[[["self"]],["result"]]],[10,"serialize_unit_struct","","Serialize a unit struct like `struct Unit` or `PhantomData<T>`.",20,[[["self"],["str"]],["result"]]],[10,"serialize_unit_variant","","Serialize a unit variant like `E::A` in `enum E { A, B }`.",20,[[["self"],["str"],["u32"],["str"]],["result"]]],[10,"serialize_newtype_struct","","Serialize a newtype struct like `struct Millimeters(u8)`.",20,[[["self"],["str"],["t"]],["result"]]],[10,"serialize_newtype_variant","","Serialize a newtype variant like `E::N` in `enum E { N(u8) }`.",20,[[["self"],["str"],["u32"],["str"],["t"]],["result"]]],[10,"serialize_seq","","Begin to serialize a variably sized sequence. This call must be followed by zero or more calls to `serialize_element`, then a call to `end`.",20,[[["self"],["option",["usize"]]],["result"]]],[10,"serialize_tuple","","Begin to serialize a statically sized sequence whose length will be known at deserialization time without looking at the serialized data. This call must be followed by zero or more calls to `serialize_element`, then a call to `end`.",20,[[["self"],["usize"]],["result"]]],[10,"serialize_tuple_struct","","Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["usize"]],["result"]]],[10,"serialize_tuple_variant","","Begin to serialize a tuple variant like `E::T` in `enum E { T(u8, u8) }`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["u32"],["str"],["usize"]],["result"]]],[10,"serialize_map","","Begin to serialize a map. This call must be followed by zero or more calls to `serialize_key` and `serialize_value`, then a call to `end`.",20,[[["self"],["option",["usize"]]],["result"]]],[10,"serialize_struct","","Begin to serialize a struct like `struct Rgb { r: u8, g: u8, b: u8 }`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["usize"]],["result"]]],[10,"serialize_struct_variant","","Begin to serialize a struct variant like `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`. This call must be followed by zero or more calls to `serialize_field`, then a call to `end`.",20,[[["self"],["str"],["u32"],["str"],["usize"]],["result"]]],[11,"collect_seq","","Collect an iterator as a sequence.",20,[[["self"],["i"]],["result"]]],[11,"collect_map","","Collect an iterator as a map.",20,[[["self"],["i"]],["result"]]],[11,"collect_str","","Serialize a string produced by an implementation of `Display`.",20,[[["self"],["t"]],["result"]]],[11,"is_human_readable","","Determine whether `Serialize` implementations should serialize in human-readable form.",20,[[["self"]],["bool"]]],[14,"forward_to_deserialize_any","","Helper macro when implementing the `Deserializer` part of a new data format for Serde.",N,N],[14,"serde_if_integer128","","Conditional compilation depending on whether Serde is built with support for 128-bit integers.",N,N],[11,"fmt","serde::de","",28,[[["self"],["formatter"]],["result",["error"]]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"to_owned","","",28,[[["self"]],["t"]]],[11,"clone_into","","",28,N],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"into","serde::de::value","",29,[[["self"]],["u"]]],[11,"to_string","","",29,[[["self"]],["string"]]],[11,"to_owned","","",29,[[["self"]],["t"]]],[11,"clone_into","","",29,N],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"to_owned","","",31,[[["self"]],["t"]]],[11,"clone_into","","",31,N],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,N],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,N],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"to_owned","","",37,[[["self"]],["t"]]],[11,"clone_into","","",37,N],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"to_owned","","",38,[[["self"]],["t"]]],[11,"clone_into","","",38,N],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"to_owned","","",39,[[["self"]],["t"]]],[11,"clone_into","","",39,N],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"to_owned","","",40,[[["self"]],["t"]]],[11,"clone_into","","",40,N],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"to_owned","","",44,[[["self"]],["t"]]],[11,"clone_into","","",44,N],[11,"from","","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"to_owned","","",46,[[["self"]],["t"]]],[11,"clone_into","","",46,N],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"to_owned","","",47,[[["self"]],["t"]]],[11,"clone_into","","",47,N],[11,"from","","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"to_owned","","",48,[[["self"]],["t"]]],[11,"clone_into","","",48,N],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"to_owned","","",49,[[["self"]],["t"]]],[11,"clone_into","","",49,N],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"into","serde::ser","",50,[[["self"]],["u"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"deserialize","serde::de","",28,[[["d"]],["result",["ignoredany"]]]],[11,"deserialize_bool","serde::de::value","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",30,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",30,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",30,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",30,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",30,N],[11,"deserialize_enum","","",30,N],[11,"deserialize_identifier","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",30,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",31,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",31,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",31,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",31,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",31,N],[11,"deserialize_enum","","",31,N],[11,"deserialize_identifier","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",31,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",32,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",32,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",32,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",32,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",32,N],[11,"deserialize_enum","","",32,N],[11,"deserialize_identifier","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",32,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",33,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",33,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",33,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",33,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",33,N],[11,"deserialize_enum","","",33,N],[11,"deserialize_identifier","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",33,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",34,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",34,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",34,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",34,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",34,N],[11,"deserialize_enum","","",34,N],[11,"deserialize_identifier","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",34,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",35,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",35,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",35,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",35,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",35,N],[11,"deserialize_enum","","",35,N],[11,"deserialize_identifier","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",35,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",36,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",36,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",36,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",36,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",36,N],[11,"deserialize_enum","","",36,N],[11,"deserialize_identifier","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",36,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",37,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",37,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",37,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",37,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",37,N],[11,"deserialize_enum","","",37,N],[11,"deserialize_identifier","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",37,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",38,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",38,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",38,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",38,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",38,N],[11,"deserialize_enum","","",38,N],[11,"deserialize_identifier","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",38,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",39,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",39,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",39,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",39,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",39,N],[11,"deserialize_enum","","",39,N],[11,"deserialize_identifier","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",39,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",40,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",40,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",40,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",40,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",40,N],[11,"deserialize_enum","","",40,N],[11,"deserialize_identifier","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",40,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",41,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",41,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",41,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",41,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",41,N],[11,"deserialize_enum","","",41,N],[11,"deserialize_identifier","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",41,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",42,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",42,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",42,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",42,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",42,N],[11,"deserialize_enum","","",42,N],[11,"deserialize_identifier","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",42,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",43,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",43,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",43,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",43,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",43,N],[11,"deserialize_enum","","",43,N],[11,"deserialize_identifier","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",43,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",44,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",44,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",44,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",44,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",44,N],[11,"deserialize_enum","","",44,N],[11,"deserialize_identifier","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",44,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",45,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",45,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",45,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",45,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",45,N],[11,"deserialize_enum","","",45,N],[11,"deserialize_identifier","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",45,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",46,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",46,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",46,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",46,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",46,N],[11,"deserialize_identifier","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",46,[[["self"],["v"]],["result"]]],[11,"deserialize_enum","","",46,N],[11,"deserialize_any","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_enum","","",47,N],[11,"deserialize_bool","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",47,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",47,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",47,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",47,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",47,N],[11,"deserialize_identifier","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",47,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_enum","","",1,N],[11,"deserialize_bool","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",1,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",1,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",1,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",1,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",1,N],[11,"deserialize_identifier","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",1,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_enum","","",48,N],[11,"deserialize_bool","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",48,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",48,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",48,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",48,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",48,N],[11,"deserialize_identifier","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",48,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_enum","","",49,N],[11,"deserialize_bool","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",49,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",49,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",49,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",49,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",49,N],[11,"deserialize_identifier","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",49,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",2,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",2,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",2,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",2,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",2,N],[11,"deserialize_identifier","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",2,[[["self"],["v"]],["result"]]],[11,"deserialize_enum","","",2,N],[11,"deserialize_any","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",3,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",3,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",3,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",3,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",3,N],[11,"deserialize_enum","","",3,N],[11,"deserialize_identifier","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",3,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",4,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",4,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",4,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",4,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",4,N],[11,"deserialize_enum","","",4,N],[11,"deserialize_identifier","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",4,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_seq","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",5,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_bool","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",5,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",5,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",5,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",5,N],[11,"deserialize_enum","","",5,N],[11,"deserialize_identifier","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",5,[[["self"],["v"]],["result"]]],[11,"deserialize_any","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_bool","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_i8","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_i16","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_i32","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_i64","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_i128","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_u8","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_u16","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_u32","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_u64","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_u128","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_f32","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_f64","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_char","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_str","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_string","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_bytes","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_byte_buf","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_option","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_unit","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_unit_struct","","",6,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_newtype_struct","","",6,[[["self"],["str"],["v"]],["result"]]],[11,"deserialize_seq","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_tuple","","",6,[[["self"],["usize"],["v"]],["result"]]],[11,"deserialize_tuple_struct","","",6,[[["self"],["str"],["usize"],["v"]],["result"]]],[11,"deserialize_map","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_struct","","",6,N],[11,"deserialize_enum","","",6,N],[11,"deserialize_identifier","","",6,[[["self"],["v"]],["result"]]],[11,"deserialize_ignored_any","","",6,[[["self"],["v"]],["result"]]],[11,"expecting","serde::de","",28,[[["self"],["formatter"]],["result"]]],[11,"visit_bool","","",28,[[["self"],["bool"]],["result"]]],[11,"visit_i64","","",28,[[["self"],["i64"]],["result"]]],[11,"visit_u64","","",28,[[["self"],["u64"]],["result"]]],[11,"visit_f64","","",28,[[["self"],["f64"]],["result"]]],[11,"visit_str","","",28,[[["self"],["str"]],["result"]]],[11,"visit_none","","",28,[[["self"]],["result"]]],[11,"visit_some","","",28,[[["self"],["d"]],["result"]]],[11,"visit_newtype_struct","","",28,[[["self"],["d"]],["result"]]],[11,"visit_unit","","",28,[[["self"]],["result"]]],[11,"visit_seq","","",28,[[["self"],["a"]],["result"]]],[11,"visit_map","","",28,[[["self"],["a"]],["result"]]],[11,"visit_bytes","","",28,N],[11,"next_element_seed","serde::de::value","",3,[[["self"],["v"]],["result",["option"]]]],[11,"size_hint","","",3,[[["self"]],["option",["usize"]]]],[11,"next_element_seed","","",5,[[["self"],["t"]],["result",["option"]]]],[11,"size_hint","","",5,[[["self"]],["option",["usize"]]]],[11,"next_key_seed","","",5,[[["self"],["t"]],["result",["option"]]]],[11,"next_value_seed","","",5,[[["self"],["t"]],["result"]]],[11,"next_entry_seed","","",5,[[["self"],["tk"],["tv"]],["result",["option"]]]],[11,"size_hint","","",5,[[["self"]],["option",["usize"]]]],[11,"variant_seed","","",46,[[["self"],["t"]],["result"]]],[11,"variant_seed","","",47,[[["self"],["t"]],["result"]]],[11,"variant_seed","","",1,[[["self"],["t"]],["result"]]],[11,"variant_seed","","",48,[[["self"],["t"]],["result"]]],[11,"variant_seed","","",49,[[["self"],["t"]],["result"]]],[11,"serialize_element","serde::ser","",50,[[["self"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"serialize_element","","",50,[[["self"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"serialize_field","","",50,[[["self"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"serialize_field","","",50,[[["self"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"serialize_key","","",50,[[["self"],["t"]],["result"]]],[11,"serialize_value","","",50,[[["self"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"serialize_field","","",50,[[["self"],["str"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"serialize_field","","",50,[[["self"],["str"],["t"]],["result"]]],[11,"end","","",50,[[["self"]],["result"]]],[11,"custom","serde::de::value","",29,[[["t"]],["self"]]],[11,"custom","","",29,[[["t"]],["self"]]],[11,"default","serde::de","",28,[[],["ignoredany"]]],[11,"eq","serde::de::value","",29,[[["self"],["error"]],["bool"]]],[11,"ne","","",29,[[["self"],["error"]],["bool"]]],[11,"eq","serde::de","",0,[[["self"],["unexpected"]],["bool"]]],[11,"ne","","",0,[[["self"],["unexpected"]],["bool"]]],[11,"clone","serde::de::value","",29,[[["self"]],["error"]]],[11,"clone","","",30,[[["self"]],["self"]]],[11,"clone","","",31,[[["self"]],["self"]]],[11,"clone","","",32,[[["self"]],["self"]]],[11,"clone","","",33,[[["self"]],["self"]]],[11,"clone","","",34,[[["self"]],["self"]]],[11,"clone","","",35,[[["self"]],["self"]]],[11,"clone","","",36,[[["self"]],["self"]]],[11,"clone","","",37,[[["self"]],["self"]]],[11,"clone","","",38,[[["self"]],["self"]]],[11,"clone","","",39,[[["self"]],["self"]]],[11,"clone","","",40,[[["self"]],["self"]]],[11,"clone","","",41,[[["self"]],["self"]]],[11,"clone","","",42,[[["self"]],["self"]]],[11,"clone","","",43,[[["self"]],["self"]]],[11,"clone","","",44,[[["self"]],["self"]]],[11,"clone","","",45,[[["self"]],["self"]]],[11,"clone","","",46,[[["self"]],["self"]]],[11,"clone","","",47,[[["self"]],["self"]]],[11,"clone","","",1,[[["self"]],["self"]]],[11,"clone","","",48,[[["self"]],["self"]]],[11,"clone","","",49,[[["self"]],["self"]]],[11,"clone","","",2,[[["self"]],["self"]]],[11,"clone","","",3,[[["self"]],["seqdeserializer"]]],[11,"clone","","",4,[[["self"]],["seqaccessdeserializer"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"clone","","",6,[[["self"]],["mapaccessdeserializer"]]],[11,"clone","serde::de","",28,[[["self"]],["ignoredany"]]],[11,"clone","","",0,[[["self"]],["unexpected"]]],[11,"fmt","serde::de::value","",29,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","serde::de","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","serde::de::value","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","serde::de","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","serde::de::value","",29,[[["self"]],["str"]]]],"paths":[[4,"Unexpected"],[3,"BorrowedStrDeserializer"],[3,"BorrowedBytesDeserializer"],[3,"SeqDeserializer"],[3,"SeqAccessDeserializer"],[3,"MapDeserializer"],[3,"MapAccessDeserializer"],[8,"Error"],[8,"Expected"],[8,"Deserialize"],[8,"DeserializeSeed"],[8,"Deserializer"],[8,"Visitor"],[8,"SeqAccess"],[8,"MapAccess"],[8,"EnumAccess"],[8,"VariantAccess"],[8,"IntoDeserializer"],[8,"Error"],[8,"Serialize"],[8,"Serializer"],[8,"SerializeSeq"],[8,"SerializeTuple"],[8,"SerializeTupleStruct"],[8,"SerializeTupleVariant"],[8,"SerializeMap"],[8,"SerializeStruct"],[8,"SerializeStructVariant"],[3,"IgnoredAny"],[3,"Error"],[3,"UnitDeserializer"],[3,"BoolDeserializer"],[3,"I8Deserializer"],[3,"I16Deserializer"],[3,"I32Deserializer"],[3,"I64Deserializer"],[3,"IsizeDeserializer"],[3,"U8Deserializer"],[3,"U16Deserializer"],[3,"U64Deserializer"],[3,"UsizeDeserializer"],[3,"F32Deserializer"],[3,"F64Deserializer"],[3,"CharDeserializer"],[3,"I128Deserializer"],[3,"U128Deserializer"],[3,"U32Deserializer"],[3,"StrDeserializer"],[3,"StringDeserializer"],[3,"CowStrDeserializer"],[3,"Impossible"]]};
searchIndex["serde_shims"]={"doc":"Meta package for all Serde shims, mostly for documentation but does re-export shims like version `0.1`.","items":[[14,"impl_serde_for_bitflags","serde_shims","Implements `Serialize` and `Deserialize` for a `bitflags!` generated structure.",N,N],[14,"impl_serde_for_enum_primitive","","Implements `Serialize` and `Deserialize` for an `enum_from_primitive!` generated enum.",N,N]],"paths":[]};
searchIndex["std_serde_shims"]={"doc":"Potentially useful shims for the standard library","items":[[0,"option","std_serde_shims","`Option` shims",N,N],[5,"serialize_none_as_default","std_serde_shims::option","Serializes `None` as `Some(Default)`",N,[[["option"],["s"]],["result"]]]],"paths":[]};
searchIndex["unicase"]={"doc":"UniCase","items":[[3,"UniCase","unicase","Case Insensitive wrapper of strings.",N,N],[3,"Ascii","","Case Insensitive wrapper of Ascii strings.",N,N],[5,"eq","","Compare two string-like types for case-less equality, using unicode folding.",N,[[["s"],["s"]],["bool"]]],[5,"eq_ascii","","Compare two string-like types for case-less equality, ignoring ASCII case.",N,[[["s"],["s"]],["bool"]]],[11,"new","","",0,[[["s"]],["ascii"]]],[11,"new","","Creates a new `UniCase`.",1,[[["s"]],["unicase"]]],[11,"unicode","","Creates a new `UniCase`, skipping the ASCII check.",1,[[["s"]],["unicase"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"into","","",1,[[["self"]],["str"]]],[11,"into","","",1,[[["self"]],["string"]]],[11,"partial_cmp","","",0,[[["self"],["self"]],["option",["ordering"]]]],[11,"partial_cmp","","",1,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",0,[[["self"],["self"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["self"]],["ordering"]]],[11,"eq","","",0,[[["self"],["s2"]],["bool"]]],[11,"eq","","",1,[[["self"],["unicase"]],["bool"]]],[11,"from","","",1,[[["str"]],["self"]]],[11,"from","","",1,[[["str"]],["self"]]],[11,"from","","",1,[[["string"]],["self"]]],[11,"from","","",1,[[["string"]],["self"]]],[11,"as_ref","","",0,[[["self"]],["str"]]],[11,"as_ref","","",1,[[["self"]],["str"]]],[11,"clone","","",1,[[["self"]],["unicase"]]],[11,"clone","","",0,[[["self"]],["ascii"]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"deref","","",0,[[["self"]],["s"]]],[11,"deref","","",1,[[["self"]],["s"]]],[11,"deref_mut","","",0,[[["self"]],["s"]]],[11,"deref_mut","","",1,[[["self"]],["s"]]],[11,"from_str","","",0,[[["str"]],["result",["ascii"]]]],[11,"from_str","","",1,[[["str"]],["result",["unicase"]]]]],"paths":[[3,"Ascii"],[3,"UniCase"]]};
initSearch(searchIndex);
